// String prototype extensions
interface String {
  splice(start: number, len: number, fill?: string): string
  htmlspecialchars(sign?: 'ENT_QUOTES' | 'ENT_NOQUOTES'): string
  tohtml(): string
  xss(): string
  escape(): string
  at(num: number): string
  toJson(): Record<string, string>
  lt(v: string): boolean
  lte(v: string): boolean
  gt(v: string): boolean
  gte(v: string): boolean
  eq(v: string): boolean
}

// Set prototype extensions
interface Set<T> {
  union(other: Set<T>): Set<T>
  difference(other: Set<T>): Set<T>
  symmetricDifference(other: Set<T>): Set<T>
  intersection(other: Set<T>): Set<T>
  isSubsetOf(other: Set<T>): boolean
  isSupersetOf(other: Set<T>): boolean
  isDisjointFrom(other: Set<T>): boolean
  equals(other: Set<T>): boolean
}

// Promise extensions
interface PromiseConstructor {
  defer<T>(): {
    promise: Promise<T>
    resolve: (value: T | PromiseLike<T>) => void
    reject: (reason?: any) => void
  }
  withResolvers<T>(): {
    promise: Promise<T>
    resolve: (value: T | PromiseLike<T>) => void
    reject: (reason?: any) => void
  }
}

// Object extensions
interface ObjectConstructor {
  empty(obj: any): boolean
  groupBy<T>(arr: T[], fn: (item: T) => string): Record<string, T[]>
  hasOwn(obj: any, key: string): boolean
}

interface Object {
  toParams(): string
}

// Number extensions
interface NumberConstructor {
  parse(val: string | number): string | number
  fromString(val: string): number
}

// Map extensions
interface MapConstructor {
  groupBy<T, K>(arr: T[], fn: (item: T) => K): Map<K, T[]>
}

// Date prototype extensions
interface Date {
  getFullWeek(): number
  getWeek(): number
  format(str?: string): string
}

// Array prototype extensions
interface Array<T> {
  flat(deep?: number, arr?: T[]): T[]
  flatMap<U>(callback: (value: T, index: number, array: T[]) => U | U[]): U[]
  at(num: number): T
  findLast(
    predicate: (value: T, index: number, obj: T[]) => boolean
  ): T | undefined
  findLastIndex(
    predicate: (value: T, index: number, obj: T[]) => boolean
  ): number
  toSorted(compareFn?: (a: T, b: T) => number): T[]
  toReversed(): T[]
  toSpliced(start: number, deleteCount?: number, ...items: T[]): T[]
  with(index: number, value: T): T[]
  group(callback: (value: T) => string): Record<string, T[]>
  groupToMap<K>(callback: (value: T) => K): Map<K, T[]>
}
